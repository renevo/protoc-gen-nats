// Code generated by protoc-gen-nats 0.0.1, DO NOT EDIT.
// source: examples/hello.proto

package helloworld

import context "context"
import json "encoding/json"
import fmt "fmt"
import http "net/http"

import nats "github.com/nats-io/nats.go"
import micro "github.com/nats-io/nats.go/micro"

// Version compatibility assertion.
// If the constant is not defined in the package, that likely means
// the package needs to be updated to work with this generated code.
const _ = nats.Version

// ====================
// HelloWorld Interface
// ====================

// Simple hello world service
//
// Service will use the "com.renevo.helloworld" service group
type HelloWorld interface {
	// Hello will say hello to the subject
	//
	// Method subject will be "com.renevo.helloworld.hello"
	Hello(context.Context, *HelloRequest) (*HelloResponse, error)

	// Echo will return the data back into the response
	//
	// Method subject will be "com.renevo.helloworld.echo"
	Echo(context.Context, *EchoRequest) (*EchoResponse, error)

	//
	// Method subject will be "com.renevo.helloworld.err"
	Err(context.Context, *EmptyRequest) (*EmptyResponse, error)
}

// ======================
// HelloWorld NATS Client
// ======================

func NewHelloWorldClient(nc *nats.Conn) HelloWorld {
	return &helloWorldClient{nc: nc}
}

var _ HelloWorld = (*helloWorldClient)(nil)

type helloWorldClient struct {
	nc *nats.Conn
}

func (impl *helloWorldClient) Hello(ctx context.Context, req *HelloRequest) (*HelloResponse, error) {
	data, _ := json.Marshal(req)
	resp, err := impl.nc.RequestWithContext(ctx, "com.renevo.helloworld.hello", data)
	if err != nil {
		return nil, err
	}

	errCode, errMessage := resp.Header.Get(micro.ErrorCodeHeader), resp.Header.Get(micro.ErrorHeader)
	if errCode != "" && errMessage != "" {
		return nil, fmt.Errorf("%s (%s)", errMessage, errCode)
	}

	var helloResponse HelloResponse
	if err := json.Unmarshal(resp.Data, &helloResponse); err != nil {
		return nil, err
	}

	return &helloResponse, nil
}

func (impl *helloWorldClient) Echo(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {
	data, _ := json.Marshal(req)
	resp, err := impl.nc.RequestWithContext(ctx, "com.renevo.helloworld.echo", data)
	if err != nil {
		return nil, err
	}

	errCode, errMessage := resp.Header.Get(micro.ErrorCodeHeader), resp.Header.Get(micro.ErrorHeader)
	if errCode != "" && errMessage != "" {
		return nil, fmt.Errorf("%s (%s)", errMessage, errCode)
	}

	var echoResponse EchoResponse
	if err := json.Unmarshal(resp.Data, &echoResponse); err != nil {
		return nil, err
	}

	return &echoResponse, nil
}

func (impl *helloWorldClient) Err(ctx context.Context, req *EmptyRequest) (*EmptyResponse, error) {
	data, _ := json.Marshal(req)
	resp, err := impl.nc.RequestWithContext(ctx, "com.renevo.helloworld.err", data)
	if err != nil {
		return nil, err
	}

	errCode, errMessage := resp.Header.Get(micro.ErrorCodeHeader), resp.Header.Get(micro.ErrorHeader)
	if errCode != "" && errMessage != "" {
		return nil, fmt.Errorf("%s (%s)", errMessage, errCode)
	}

	var emptyResponse EmptyResponse
	if err := json.Unmarshal(resp.Data, &emptyResponse); err != nil {
		return nil, err
	}

	return &emptyResponse, nil
}

// =================================
// HelloWorld Micro Service Handlers
// =================================

// NewHelloWorldServer builds a new micro.Service that will be registered with the instance provided
// Each RPC on the service will be mapped to a new endpoint within the micro service
func NewHelloWorldServer(rootCtx context.Context, version string, nc *nats.Conn, impl HelloWorld) (micro.Service, error) {
	svc, err := micro.AddService(nc, micro.Config{
		Name:        "com-renevo-helloworld",
		Version:     version,
		Description: " Simple hello world service",
		Metadata: map[string]string{
			"package": "com.renevo.helloworld",
			"name":    "HelloWorld",
		},
	})

	if err != nil {
		return nil, fmt.Errorf("failed to create nats service: %w", err)
	}

	group := svc.AddGroup("com.renevo.helloworld")

	if err := group.AddEndpoint("hello", micro.ContextHandler(rootCtx, func(ctx context.Context, req micro.Request) {
		var helloRequest HelloRequest
		if err := json.Unmarshal(req.Data(), &helloRequest); err != nil {
			_ = req.Error(http.StatusText(http.StatusBadRequest), err.Error(), nil)
			return
		}

		helloResponse, err := impl.Hello(ctx, &helloRequest)
		if err != nil {
			_ = req.Error(http.StatusText(http.StatusInternalServerError), err.Error(), nil)
			return
		}

		_ = req.RespondJSON(helloResponse)
	})); err != nil {
		return nil, fmt.Errorf("failed to add endpoint %q: %w", "hello", err)
	}

	if err := group.AddEndpoint("echo", micro.ContextHandler(rootCtx, func(ctx context.Context, req micro.Request) {
		var echoRequest EchoRequest
		if err := json.Unmarshal(req.Data(), &echoRequest); err != nil {
			_ = req.Error(http.StatusText(http.StatusBadRequest), err.Error(), nil)
			return
		}

		echoResponse, err := impl.Echo(ctx, &echoRequest)
		if err != nil {
			_ = req.Error(http.StatusText(http.StatusInternalServerError), err.Error(), nil)
			return
		}

		_ = req.RespondJSON(echoResponse)
	})); err != nil {
		return nil, fmt.Errorf("failed to add endpoint %q: %w", "echo", err)
	}

	if err := group.AddEndpoint("err", micro.ContextHandler(rootCtx, func(ctx context.Context, req micro.Request) {
		var emptyRequest EmptyRequest
		if err := json.Unmarshal(req.Data(), &emptyRequest); err != nil {
			_ = req.Error(http.StatusText(http.StatusBadRequest), err.Error(), nil)
			return
		}

		emptyResponse, err := impl.Err(ctx, &emptyRequest)
		if err != nil {
			_ = req.Error(http.StatusText(http.StatusInternalServerError), err.Error(), nil)
			return
		}

		_ = req.RespondJSON(emptyResponse)
	})); err != nil {
		return nil, fmt.Errorf("failed to add endpoint %q: %w", "err", err)
	}

	return svc, nil
}

var natsFileDescriptor0 = []byte{
	// 258 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0xc1, 0x4a, 0xc3, 0x40,
	0x10, 0x86, 0xa9, 0x46, 0xc5, 0x31, 0x55, 0x18, 0x14, 0x4a, 0x11, 0xd1, 0x8d, 0x87, 0x9e, 0x36,
	0xa0, 0x6f, 0x20, 0x04, 0xbc, 0x29, 0xb9, 0x08, 0xde, 0x92, 0x74, 0x30, 0x4a, 0xd2, 0x8d, 0xbb,
	0x1b, 0xad, 0x67, 0x5f, 0x5c, 0x76, 0xba, 0xb1, 0x11, 0x9b, 0xde, 0x66, 0x86, 0x8f, 0x9f, 0xff,
	0xdb, 0x85, 0x53, 0x5a, 0x66, 0x75, 0x53, 0x91, 0x89, 0x4b, 0xaa, 0x2a, 0x25, 0x1b, 0xad, 0xac,
	0xc2, 0xb3, 0x42, 0xd5, 0x52, 0xd3, 0x82, 0x3e, 0x94, 0xe4, 0xfb, 0xa7, 0xd2, 0xd5, 0x5c, 0xcc,
	0x20, 0xbc, 0x77, 0x5b, 0x4a, 0xef, 0x2d, 0x19, 0x8b, 0x13, 0x38, 0x30, 0x6d, 0xfe, 0x46, 0x85,
	0x9d, 0x8c, 0x2e, 0x47, 0xb3, 0xc3, 0xb4, 0x5b, 0x45, 0x04, 0x63, 0x4f, 0x9a, 0x46, 0x2d, 0x0c,
	0x21, 0x42, 0x60, 0x69, 0xd9, 0x71, 0x3c, 0x8b, 0x2b, 0x38, 0x4a, 0x8a, 0xf2, 0x37, 0x0d, 0x21,
	0x98, 0x67, 0x36, 0x63, 0x24, 0x4c, 0x79, 0x16, 0x02, 0xc2, 0x15, 0xb2, 0x8e, 0xf9, 0xc7, 0x9c,
	0xc0, 0x38, 0xa9, 0x1b, 0xfb, 0xd5, 0x41, 0xe2, 0x18, 0x42, 0x7f, 0xe0, 0xe0, 0x9b, 0xef, 0x1d,
	0x00, 0x6e, 0xf3, 0xe4, 0x2c, 0x30, 0x85, 0x3d, 0xde, 0x30, 0x92, 0x1b, 0x35, 0x65, 0xdf, 0x71,
	0x7a, 0xbd, 0x1d, 0xf2, 0xbd, 0x1e, 0x20, 0x70, 0x3d, 0x51, 0x0c, 0xd0, 0x3d, 0xcf, 0x69, 0xb4,
	0x95, 0xf1, 0x81, 0x8f, 0xb0, 0x9b, 0x68, 0x3d, 0x58, 0xb1, 0xef, 0x37, 0x58, 0xf1, 0xcf, 0xab,
	0xdc, 0x5d, 0x3c, 0x9f, 0xbf, 0xbc, 0xda, 0xb2, 0xcd, 0x1d, 0x1d, 0xaf, 0xe8, 0x78, 0x4d, 0xe7,
	0xfb, 0xfc, 0xf5, 0xb7, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x12, 0x17, 0xc5, 0x4f, 0x12, 0x02,
	0x00, 0x00,
}
